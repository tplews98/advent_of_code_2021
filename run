#!/usr/bin/python3

"""Runner for Advent of Code 2021 executables."""


from __future__ import annotations

import argparse
import subprocess
import os
import time


THIS_DIR = os.path.dirname(os.path.abspath(__file__))

DAY_STR = "day_{day}"
DAY_C_FILE = os.path.join(THIS_DIR, f"src/{DAY_STR}.c")
DAY_INPUT = os.path.join(THIS_DIR, f"data/{DAY_STR}_input.txt")
DAY_TEST_INPUT = os.path.join(THIS_DIR, f"data/{DAY_STR}_test_input.txt")
DAY_OBJ_FILE = os.path.join(THIS_DIR, f"src/{DAY_STR}")
UTILS_FILE = os.path.join(THIS_DIR, "src/utils.c")


def parse_args() -> argparse.Namespace:
    """Setup parser and parse command line args."""

    def check_mutually_exclusive_arguments(pargs: argparse.Namespace) -> None:
        """
        Check if any mutually exclusive arguments have been given. Raise error
        if so.
        """
        template = "Cannot use {arg_1} and {arg_2} together"

        if pargs.compile:
            if pargs.test:
                raise Exception(
                    template.format(arg_1="--compile", arg_2="--test")
                )
            if pargs.valgrind:
                raise Exception(
                    template.format(arg_1="--compile", arg_2="--valgrind")
                )

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "day", help="Day to run, or 'all' for all existing days"
    )
    parser.add_argument(
        "--compile",
        action="store_true",
        help="Compile source file before running",
    )
    parser.add_argument(
        "--valgrind",
        action="store_true",
        help="Run with valgrind to test for memory leaks",
    )
    parser.add_argument(
        "--test",
        action="store_true",
        help="Run with test input instead of real input",
    )
    parser.add_argument(
        "--time",
        action="store_true",
        help=(
            "Print the time to run the executable (including python "
            "subprocess time)"
        ),
    )

    pargs = parser.parse_args()

    try:
        pargs.day = int(pargs.day)
    except ValueError:
        if pargs.day != "all":
            raise ValueError("Day must be between 1 and 25 or 'all'") from None
    else:
        if not 1 <= pargs.day <= 25:
            raise ValueError("Day must be between 1 and 25, or 'all'")

    check_mutually_exclusive_arguments(pargs)

    return pargs


def get_days_to_run(pargs: argparse.Namespace) -> list[int]:
    """
    Find the days to run commands with.

    If pargs.day is an integer, that day is used.
    If pargs.day is 'all', all existing days are used.

    """

    def check_day_exists(day: int) -> None:
        """Check the days .c file and input exist. Raises an error if not."""
        files_to_check = [
            DAY_C_FILE,
            DAY_INPUT,
            DAY_TEST_INPUT,
        ]

        for file_path in files_to_check:
            file_path = file_path.format(day=f"{day:02}")
            if not os.path.exists(file_path):
                raise FileNotFoundError(
                    f"'{file_path}' does not exist, cannot run for this day"
                )

        if not pargs.compile:
            file_path = DAY_OBJ_FILE.format(day=f"{day:02}")
            if not os.path.exists(file_path):
                raise FileNotFoundError(
                    f"'{file_path}' does not exist. Try --compile first"
                )

    days = []

    if pargs.day != "all":
        check_day_exists(pargs.day)
        days.append(pargs.day)
    else:
        for day in range(1, 26):
            try:
                check_day_exists(day)
                days.append(day)
            except FileNotFoundError:
                # Day solution doesn't exist.
                continue

        if not days:
            print(
                "No days have all necessary files to run, maybe try --compile"
            )
            return days

        # Check that days are consecutive, print error if any were missing for
        # which a later day exists.
        missing_days = sorted(set(range(1, max(days))) - set(days))
        if missing_days:
            print(
                "Some days were missing where a later day exists: "
                f"{', '.join(str(day) for day in missing_days)}"
            )

    return days


def run_cmd(cmd: list[str], *, print_time: bool = False) -> None:
    """Run a subprocess command and optionally print the time to run it."""
    start = time.perf_counter()
    subprocess.run(cmd, check=True)
    end = time.perf_counter()
    total_time = end - start
    if print_time:
        if total_time > 1:
            time_str = f"{total_time:.3f}s"
        elif total_time > 10 ** -3:
            time_str = f"{total_time * 10 ** 3:.3f}ms"
        elif total_time > 10 ** -6:
            time_str = f"{total_time * 10 ** 6:.3f}us"
        else:
            time_str = f"{total_time * 10 ** 9:.0f}ns"
        print(f"Time to run (including python subprocess time): {time_str}")


def main() -> None:
    """
    Main runner. Parse args and run a day's script (and optionally compile).
    """
    pargs = parse_args()

    days = get_days_to_run(pargs)
    for day in days:
        day_c_file = DAY_C_FILE.format(day=f"{day:02}")
        day_obj_file = DAY_OBJ_FILE.format(day=f"{day:02}")
        day_input = DAY_INPUT.format(day=f"{day:02}")
        day_test_input = DAY_TEST_INPUT.format(day=f"{day:02}")

        if pargs.compile:
            cmd = [
                "clang",
                "-g",
                "-O3",
                "-Wall",
                day_c_file,
                UTILS_FILE,
                "-o",
                day_obj_file,
            ]
            print(f"----- Compiling day {day} -----")
            run_cmd(cmd, print_time=pargs.time)
        else:
            txt_file = day_input if not pargs.test else day_test_input

            cmd = [day_obj_file, txt_file]
            if pargs.valgrind:
                cmd.insert(0, "valgrind")

            print(f"----- Day {day} -----")
            run_cmd(cmd, print_time=pargs.time)


if __name__ == "__main__":
    main()
